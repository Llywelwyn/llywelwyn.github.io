<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style/prism-ide.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js"></script>
    <link rel="stylesheet" href="/style/style-ide.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
     
    <title>  Llyw - posts  </title>
</head>

<body>
    <div id='content'>
        
<header>
    <b><a href="/">posts</a></b>
    | <a href="/tags/">tags</a>
    | <a href="/links/">misc. links</a>
    | <a href="/rl/">play rust-rl here</a>
</header>

<h1 class="title">RUST-RL does /r/roguelikedev follows the complete tutorial, week 2</h1>

<div class="post-tags">
    
    <a href="/tags/RUST-RL/">RUST-RL</a>, <a href="/tags/roguelikedev/">roguelikedev</a>, <a href="/tags/procgen/">procgen</a>
    | 2023-07-18
</div>

<p>procgen this week! and probably for the next long time. i messed around with the bitmask being used for the walls, and got chained builders in. of those things, the chains are the most fun to talk about.</p>
<h2>chained builders</h2>
<p>this is more or less straight from bracket, but i think it's interesting to talk about. in essence, instead of defining one function that's generating a map from some parameters, map generation has turned into a modular chain of builders, that each accept the build data from the previous builder, and do some procgen magic, and then pass the build data on to the next builder.</p>
<p>here's a lengthy example of a map that might end up being rolled</p>
<pre><code class="language-rust">let mut builder = BuilderChain::new(new_depth, width, height);
builder.start_with(BspDungeonBuilder::new());
builder.with(RoomSorter::new(RoomSort::CENTRAL));
builder.with(RoomDrawer::new());
builder.with(BresenhamCorridors::new());
builder.with(RoomCornerRounder::new());
builder.with(RoomBasedStartingPosition::new());
builder.with(DistantExit::new());
builder.with(RoomBasedSpawner::new());
</code></pre>
<p>it looks difficult to interpret compared to an all-in-one, one-liner like </p>
<pre><code class="language-rust">build_dungeon()
</code></pre>
<p>but if you take into account that almost all of these individual build steps are optional, as well as the fact that each build step is doing one single, very specific modification to the build data, it gets a lot simpler.</p>
<p>first, a completely blank slate is made, with given dimensions, and then the first step of a BspDungeon algorithm is ran: the map is split into rects, but left empty for now. the information about where the rects are is stored in the build data as a list of rooms</p>
<pre><code class="language-rust">let mut builder = BuilderChain::new(new_depth, width, height);
builder.start_with(BspDungeonBuilder::new());
</code></pre>
<p>this gets followed up by a sort. in this case, it starts from the centre of the map and sorts the rooms from nearest-to-furthest, ending up with a spiral-ish order. this doesn't do anything on its own otherwise; the sorting is just for future reference by the next builders in the chain.</p>
<pre><code class="language-rust">builder.with(RoomSorter::new(RoomSort::CENTRAL));
</code></pre>
<p>with sorted rooms, the next step is to <em>actually draw them to the map</em>. what we have right now is a list of places where rooms should go, but they're still all empty, and there aren't any walls. so that's what the next two builders in the chain do: following our sorted order from centre-most to outer-most, we first draw every single room to the map, and then follow it up by drawing corridors between them - in this case, with straight Bresenham lines from centre-to-centre; and because we sorted in this way, we end up with a map that starts in the centre and expands outwards.</p>
<pre><code class="language-rust">builder.with(RoomDrawer::new());
builder.with(BresenhamCorridors::new());
</code></pre>
<p>we don't want square rooms! the RoomCornerRounder iterates through the rooms we've just drawn, and fills in the corners to make something that looks more natural than perfect squares. this approach is pretty good for something like a warren, or a cave system that you still want to have corridors between.</p>
<pre><code class="language-rust">builder.with(RoomCornerRounder::new());
</code></pre>
<p>finally, we decide where the player should start, where they need to go do continue on through the dungeon, and where we want the mobs to spawn. in this example, we've got the player starting in a random room, the exit is being placed <em>as far away as possible</em>, even outside of rooms (it can end up in a corridor between rooms), and mobs are spawning <em>only</em> within rooms. they can still wander out of them, but the map'll start off with clear corridors.</p>
<pre><code class="language-rust">builder.with(RoomBasedStartingPosition::new());
builder.with(DistantExit::new());
builder.with(RoomBasedSpawner::new());
</code></pre>
<p>of all of these stages, the only ones that are completely mandatory are a starting point (like BspDungeonBuilder, in this case), and the player's start- and end-points. we need <em>some sort</em> of map, somewhere for the player <em>to start</em>, somewhere for them <em>to go</em>; you don't even need somewhere for the monsters to spawn. if you want perfectly rectangular rooms, RoomCornerRounder could be skipped; if you want monsters to start in corridors, VoronoiSpawning could be used instead of RoomBased; if you don't like BspDungeons? you can substitute something else in it's place.</p>
<p>but in this case, here's what we ended up getting.</p>
<p><img src="/assets/builder-chain.png" alt="image" /></p>
<p>hopefully this is at least a somewhat decent show of how a chain of builders can be beneficial. there's <em>a lot</em> of room to expand or modify a system like this, so this is where procgen becomes really fun. dungeon features, themeing different rooms, spawning a dragon in the largest room - anything.</p>



        <div id='footer'>
            <a type="application/atom+xml" rel="alternate" href="/feed.xml"><img
                    src="/assets/rss-feed.svg" alt="Atom Feed"></a>
        </div>
    </div>
</body>

</html>